# React 앱 성능 최적화

## 1. `useMemo`와 `useCallback`을 통한 성능 최적화

### **1.1 `useMemo`: 값 캐싱**
- **목적**: 계산 비용이 높은 값을 메모이제이션하여 불필요한 재계산 방지.
- **사용 예시**:
```jsx
import React, { useMemo, useState } from "react";
import { View, TextInput, Text, StyleSheet } from "react-native";

const ExpensiveCalculation = ({ num }) => {
  const calculateFactorial = (n) => {
    console.log("Calculating..."); // 계산 발생 시 로그 확인용
    return n <= 0 ? 1 : n * calculateFactorial(n - 1);
  };

  const factorial = useMemo(() => calculateFactorial(num), [num]);

  return (
    <Text style={styles.result}>
      Factorial of {num} is {factorial}
    </Text>
  );
};

const App = () => {
  const [number, setNumber] = useState("5");

  return (
    <View style={styles.container}>
      <TextInput
        style={styles.input}
        keyboardType="numeric"
        value={number.toString()}
        onChangeText={(value) => setNumber(value.replace(/[^0-9]/g, ""))}
        placeholder="Enter a number"
      />
      <ExpensiveCalculation num={Number(number) || 0} />
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 20,
    justifyContent: "center",
  },
  input: {
    height: 40,
    borderColor: "#007AFF",
    borderWidth: 1,
    borderRadius: 8,
    paddingHorizontal: 10,
    marginBottom: 20,
  },
  result: {
    fontSize: 18,
    color: "#333",
    fontWeight: "500",
    textAlign: "center",
  },
});

export default App;

```

#### **핵심 포인트**
- `useMemo`는 값(결과)을 캐싱하여 필요할 때만 재계산합니다.
- 의존성 배열(`[]`) 안의 값이 변경될 때만 함수가 실행됩니다.

---

### **1.2 `useCallback`: 함수 캐싱**
- **목적**: 동일한 함수 참조를 유지하여 자식 컴포넌트의 불필요한 렌더링 방지.
- **사용 예시**:
```jsx
import React, { useCallback, useState } from "react";
import { View, Text, TouchableOpacity, StyleSheet } from "react-native";

const Child = React.memo(({ onPress }) => {
  console.log("Child rendered"); // 리렌더링 확인용
  return (
    <TouchableOpacity style={styles.button} onPress={onPress}>
      <Text style={styles.buttonText}>Click me</Text>
    </TouchableOpacity>
  );
});

const App = () => {
  const [count, setCount] = useState(0);

  const handlePress = useCallback(() => {
    console.log("Button clicked");
  }, []);

  return (
    <View style={styles.container}>
      <Text style={styles.count}>Count: {count}</Text>
      <TouchableOpacity
        style={[styles.button, styles.incrementButton]}
        onPress={() => setCount(prev => prev + 1)}
      >
        <Text style={styles.buttonText}>Increment</Text>
      </TouchableOpacity>
      <Child onPress={handlePress} />
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: "center",
    alignItems: "center",
    backgroundColor: "#F5F5F5",
  },
  count: {
    fontSize: 24,
    marginBottom: 20,
    color: "#333",
  },
  button: {
    backgroundColor: "#007AFF",
    paddingVertical: 12,
    paddingHorizontal: 24,
    borderRadius: 8,
    marginVertical: 8,
  },
  incrementButton: {
    backgroundColor: "#34C759",
  },
  buttonText: {
    color: "white",
    fontSize: 16,
    fontWeight: "bold",
  },
});

export default App;

```

#### **핵심 포인트**
- `useCallback`은 함수 자체를 캐싱하여 자식 컴포넌트가 매번 재렌더링되는 것을 방지합니다.
- 의존성 배열에 따라 함수가 재생성됩니다.

---

## 2. 불필요한 렌더링 방지와 리소스 관리 전략

### **2.1 `React.memo`를 활용한 컴포넌트 메모이제이션**
- **목적**: 부모 컴포넌트가 리렌더링될 때, 자식 컴포넌트가 불필요하게 리렌더링되지 않도록 방지.
- **사용 예시**:
```jsx
import React, { useState } from "react";
import { View, TextInput, TouchableOpacity, Text, StyleSheet } from "react-native";

const Child = React.memo(({ value }) => {
  console.log("Child rendered"); // 리렌더링 확인용
  return <Text style={styles.valueText}>Value: {value}</Text>;
});

const App = () => {
  const [count, setCount] = useState(0);
  const [text, setText] = useState("");

  return (
    <View style={styles.container}>
      <TextInput
        style={styles.input}
        value={text}
        onChangeText={setText}
        placeholder="Type something..."
      />
      <TouchableOpacity
        style={styles.button}
        onPress={() => setCount(prev => prev + 1)}
      >
        <Text style={styles.buttonText}>Increment</Text>
      </TouchableOpacity>
      <Child value={count} />
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 20,
    justifyContent: "center",
  },
  input: {
    height: 40,
    borderColor: "#007AFF",
    borderWidth: 1,
    borderRadius: 8,
    paddingHorizontal: 10,
    marginBottom: 16,
  },
  button: {
    backgroundColor: "#34C759",
    paddingVertical: 12,
    borderRadius: 8,
    alignItems: "center",
    marginBottom: 16,
  },
  buttonText: {
    color: "white",
    fontWeight: "bold",
  },
  valueText: {
    fontSize: 18,
    color: "#333",
    textAlign: "center",
  },
});

export default App;

```

#### **핵심 포인트**
- `React.memo`는 props가 변경되지 않으면 컴포넌트를 다시 렌더링하지 않습니다.

---

### **2.2 상태 관리 최적화**
- 상태를 최소화하고 필요한 곳에만 전달합니다.
- 전역 상태 관리는 Context API나 Redux와 같은 도구를 활용합니다.

#### Best Practices:
1. 상태를 가능한 한 로컬로 유지.
2. 전역 상태는 최소화.
3. 복잡한 상태 로직은 별도의 커스텀 훅이나 리듀서로 분리.

---

## 3. 상태 업데이트 방식 비교: `useState` vs `useReducer`

### **3.1 `useState`: 단순 상태 관리**
- 간단한 상태 업데이트에 적합.
- 코드가 간결하며 직관적.

#### 사용 예시:
```jsx
import React, { useState } from "react";
import { View, Text, TouchableOpacity, StyleSheet } from "react-native";

function Counter() {
  const [count, setCount] = useState(0);

  return (
    <View style={styles.container}>
      <Text style={styles.countText}>Count: {count}</Text>
      <TouchableOpacity
        style={styles.button}
        onPress={() => setCount(count + 1)}
      >
        <Text style={styles.buttonText}>Increment</Text>
      </TouchableOpacity>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    alignItems: "center",
    justifyContent: "center",
    padding: 24,
    flex: 1,
  },
  countText: {
    fontSize: 22,
    marginBottom: 16,
    color: "#222",
  },
  button: {
    backgroundColor: "#007AFF",
    paddingHorizontal: 24,
    paddingVertical: 12,
    borderRadius: 8,
  },
  buttonText: {
    color: "#fff",
    fontWeight: "bold",
    fontSize: 16,
  },
});

export default Counter;

```

#### 적합한 상황:
- 단일 값이나 단순한 상태 관리.

---

### **3.2 `useReducer`: 복잡한 상태 로직**
- 복잡한 상태 로직이나 여러 값이 연관된 경우 적합.
- 상태와 업데이트 로직을 분리하여 가독성을 높임.

#### 사용 예시:
```jsx
function reducer(state, action) {
  switch (action.type) {
    case "increment":
      return { count: state.count + 1 };
    case "decrement":
      return { count: state.count - 1 };
    default:
      throw new Error();
  }
}

import React, { useReducer } from "react";
import { View, Text, TouchableOpacity, StyleSheet } from "react-native";

// 리듀서 함수 정의
const reducer = (state, action) => {
  switch (action.type) {
    case "increment":
      return { count: state.count + 1 };
    case "decrement":
      return { count: state.count - 1 };
    default:
      throw new Error("Unknown action type");
  }
};

function Counter() {
  const [state, dispatch] = useReducer(reducer, { count: 0 });

  return (
    <View style={styles.container}>
      <Text style={styles.countText}>Count: {state.count}</Text>
      
      <View style={styles.buttonGroup}>
        <TouchableOpacity
          style={[styles.button, styles.decrementButton]}
          onPress={() => dispatch({ type: "decrement" })}
        >
          <Text style={styles.buttonText}>-</Text>
        </TouchableOpacity>

        <TouchableOpacity
          style={[styles.button, styles.incrementButton]}
          onPress={() => dispatch({ type: "increment" })}
        >
          <Text style={styles.buttonText}>+</Text>
        </TouchableOpacity>
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: "center",
    alignItems: "center",
    backgroundColor: "#F8F9FA",
  },
  countText: {
    fontSize: 32,
    fontWeight: "bold",
    marginBottom: 24,
    color: "#333",
  },
  buttonGroup: {
    flexDirection: "row",
    gap: 16,
  },
  button: {
    width: 60,
    height: 60,
    borderRadius: 30,
    justifyContent: "center",
    alignItems: "center",
    elevation: 3, // 안드로이드 그림자
    shadowColor: "#000", // iOS 그림자
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.2,
  },
  incrementButton: {
    backgroundColor: "#34C759",
  },
  decrementButton: {
    backgroundColor: "#FF3B30",
  },
  buttonText: {
    color: "white",
    fontSize: 24,
    fontWeight: "bold",
  },
});

export default Counter;

```

#### 적합한 상황:
- 복잡한 상태 트랜지션이 필요한 경우.
- 여러 하위 상태를 하나로 관리해야 하는 경우.

---

### **3.3 선택 기준**
| 특징               | `useState`                              | `useReducer`                          |
|--------------------|-----------------------------------------|---------------------------------------|
| 단순/복잡도       | 단순한 상태 관리                       | 복잡한 상태 로직                     |
| 코드 가독성       | 간결하고 직관적                         | 초기 설정이 다소 복잡                 |
| 상태 의존성       | 이전 상태 의존성이 적음                 | 이전 상태와 연관된 업데이트에 유리     |
| 사용 사례         | 토글 버튼, 입력 필드 등                | 복잡한 폼, 다중 상태 관리             |

---

## 요약 및 과제

### 요약
1. **`useMemo`, `useCallback`**을 사용해 불필요한 계산과 함수 생성 방지.
2. **`React.memo`**로 컴포넌트 리렌더링 최소화.
3. 간단한 상태는 `useState`, 복잡한 로직은 `useReducer`.

### 과제
1. `React.memo`, `useCallback`, 그리고 `useReducer`를 활용하여 간단한 Todo 앱을 만들어보세요.
2. Context API와 함께 `useReducer`를 사용해 전역 상태를 관리하는 프로젝트를 구현해보세요.
